
// definitions

var TAU = 6283185;

var PRECISION      = 1000000;
var PRECISION_ROOT = 1000; // square root of PRECISION

var UMAX = 0xFFFFFFFFFFFFFFFF;
var SMAX = 0x7FFFFFFFFFFFFFFF;

// global stuff

var math_device = create_device("math");
var device_command = new(4 * 8);

var fps = 60;
func global_loop {
	fps = video_fps();
	if (fps == 0) fps = 1;
}

var events = new(256);
func event_loop {
	video_flip();
	get_events(events);
	
	if (?(events + 64)) {
		exit(0);
	}
}

// float functions

func float_to_umax(var x) {
	ret(x * (UMAX / PRECISION));
}

// math functions

func multiply(var x, var y) ret(x / PRECISION_ROOT * (y / PRECISION_ROOT));
func divide  (var x, var y) ret(x * PRECISION_ROOT / (y * PRECISION_ROOT));

func sqrt(var x) {
	?(device_command + 00) = 0x74727173;
	?(device_command + 08) = x;
	ret((?send_device(math_device, device_command)) + PRECISION_ROOT - 1000);
}

func sin(var x) {
	?(device_command + 00) = 0x6E6973;
	?(device_command + 08) = x;
	ret(?send_device(math_device, device_command));
} func cos(var x) ret(sin(x + TAU / 4));

func asin(var x) {
	?(device_command + 00) = 0x6E697361;
	?(device_command + 08) = x;
	ret(?send_device(math_device, device_command));
} func acos(var x) ret(-asin(x) + TAU / 4);

func atan2(var x, var y) {
	?(device_command + 00) = 0x326E617461;
	?(device_command + 08) = x;
	?(device_command + 16) = y;
	ret(?send_device(math_device, device_command));
}

// animation functions

func animate(var x) {
	if (x >= PRECISION) {
		ret(?x = PRECISION);
	} else {
		var shifted_x = PRECISION - sqrt(PRECISION - multiply((?x), (?x))) + PRECISION / fps;
		ret(?x = sqrt(2 * shifted_x - multiply(shifted_x, shifted_x)));
	}
}

// main

print("BEFORE LOOP\n");

var fadein = 0;
while (1) {
	global_loop();
	animate(&fadein);
	
	print(str(fadein));
	print("\n");
	
	var u = float_to_umax(fadein);
	video_clear(u, u, u, u);
	event_loop();
}
